{"version":3,"file":"ng-let.mjs","sources":["../../../projects/ng-let/src/lib/ng-let.directive.ts","../../../projects/ng-let/src/lib/ng-let.module.ts","../../../projects/ng-let/src/public-api.ts","../../../projects/ng-let/src/ng-let.ts"],"sourcesContent":["import { Directive, Input, TemplateRef, ViewContainerRef } from '@angular/core';\r\n\r\ninterface NgLetContext<T> {\r\n    ngLet: T;\r\n    $implicit: T;\r\n}\r\n\r\n@Directive({\r\n    // tslint:disable-next-line: directive-selector\r\n    selector: '[ngLet]'\r\n})\r\nexport class NgLetDirective<T> {\r\n\r\n    private context: NgLetContext<T | null> = { ngLet: null, $implicit: null };\r\n    private hasView: boolean = false;\r\n\r\n    // eslint-disable-next-line no-unused-vars\r\n    constructor(private viewContainer: ViewContainerRef, private templateRef: TemplateRef<NgLetContext<T>>) { }\r\n\r\n    @Input()\r\n    set ngLet(value: T) {\r\n        this.context.$implicit = this.context.ngLet = value;\r\n        if (!this.hasView) {\r\n            this.viewContainer.createEmbeddedView(this.templateRef, this.context);\r\n            this.hasView = true;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public static ngLetUseIfTypeGuard: void;\r\n\r\n    /**\r\n     * Assert the correct type of the expression bound to the `NgLet` input within the template.\r\n     *\r\n     * The presence of this static field is a signal to the Ivy template type check compiler that\r\n     * when the `NgLet` structural directive renders its template, the type of the expression bound\r\n     * to `NgLet` should be narrowed in some way. For `NgLet`, the binding expression itself is used to\r\n     * narrow its type, which allows the strictNullChecks feature of TypeScript to work with `NgLet`.\r\n     */\r\n    static ngTemplateGuard_ngLet: 'binding';\r\n\r\n    /**\r\n     * Asserts the correct type of the context for the template that `NgLet` will render.\r\n     *\r\n     * The presence of this method is a signal to the Ivy template type-check compiler that the\r\n     * `NgLet` structural directive renders its template with a specific context type.\r\n     */\r\n    static ngTemplateContextGuard<T>(dir: NgLetDirective<T>, ctx: any): ctx is NgLetContext<Exclude<T, false | 0 | '' | null | undefined>> {\r\n        return true;\r\n    }\r\n}\r\n","import { NgModule } from '@angular/core';\nimport { NgLetDirective } from './ng-let.directive';\n\n@NgModule({\n  declarations: [NgLetDirective],\n  imports: [],\n  exports: [NgLetDirective],\n  providers: []\n})\nexport class NgLetModule { }\n","/*\r\n * Public API Surface of ng-let\r\n */\r\nexport * from './lib/ng-let.module';\r\nexport * from './lib/ng-let.directive';\r\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],"names":[],"mappings":";;;MAWa,cAAc;;IAMvB,YAAoB,aAA+B,EAAU,WAAyC;QAAlF,kBAAa,GAAb,aAAa,CAAkB;QAAU,gBAAW,GAAX,WAAW,CAA8B;QAJ9F,YAAO,GAA2B,EAAE,KAAK,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC;QACnE,YAAO,GAAY,KAAK,CAAC;KAG0E;IAE3G,IACI,KAAK,CAAC,KAAQ;QACd,IAAI,CAAC,OAAO,CAAC,SAAS,GAAG,IAAI,CAAC,OAAO,CAAC,KAAK,GAAG,KAAK,CAAC;QACpD,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;YACf,IAAI,CAAC,aAAa,CAAC,kBAAkB,CAAC,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC;YACtE,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;SACvB;KACJ;;;;;;;IAqBD,OAAO,sBAAsB,CAAI,GAAsB,EAAE,GAAQ;QAC7D,OAAO,IAAI,CAAC;KACf;;2GAtCQ,cAAc;+FAAd,cAAc;2FAAd,cAAc;kBAJ1B,SAAS;mBAAC;;oBAEP,QAAQ,EAAE,SAAS;iBACtB;iIAUO,KAAK;sBADR,KAAK;;;MCVG,WAAW;;wGAAX,WAAW;yGAAX,WAAW,iBALP,cAAc,aAEnB,cAAc;yGAGb,WAAW,aAFX,EAAE,YAFJ,EAAE;2FAIA,WAAW;kBANvB,QAAQ;mBAAC;oBACR,YAAY,EAAE,CAAC,cAAc,CAAC;oBAC9B,OAAO,EAAE,EAAE;oBACX,OAAO,EAAE,CAAC,cAAc,CAAC;oBACzB,SAAS,EAAE,EAAE;iBACd;;;ACRD;;;;ACAA;;;;;;"}