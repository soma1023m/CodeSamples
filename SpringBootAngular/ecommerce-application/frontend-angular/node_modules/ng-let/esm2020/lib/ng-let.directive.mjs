import { Directive, Input } from '@angular/core';
import * as i0 from "@angular/core";
export class NgLetDirective {
    // eslint-disable-next-line no-unused-vars
    constructor(viewContainer, templateRef) {
        this.viewContainer = viewContainer;
        this.templateRef = templateRef;
        this.context = { ngLet: null, $implicit: null };
        this.hasView = false;
    }
    set ngLet(value) {
        this.context.$implicit = this.context.ngLet = value;
        if (!this.hasView) {
            this.viewContainer.createEmbeddedView(this.templateRef, this.context);
            this.hasView = true;
        }
    }
    /**
     * Asserts the correct type of the context for the template that `NgLet` will render.
     *
     * The presence of this method is a signal to the Ivy template type-check compiler that the
     * `NgLet` structural directive renders its template with a specific context type.
     */
    static ngTemplateContextGuard(dir, ctx) {
        return true;
    }
}
NgLetDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NgLetDirective, deps: [{ token: i0.ViewContainerRef }, { token: i0.TemplateRef }], target: i0.ɵɵFactoryTarget.Directive });
NgLetDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.1", type: NgLetDirective, selector: "[ngLet]", inputs: { ngLet: "ngLet" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NgLetDirective, decorators: [{
            type: Directive,
            args: [{
                    // tslint:disable-next-line: directive-selector
                    selector: '[ngLet]'
                }]
        }], ctorParameters: function () { return [{ type: i0.ViewContainerRef }, { type: i0.TemplateRef }]; }, propDecorators: { ngLet: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmctbGV0LmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Byb2plY3RzL25nLWxldC9zcmMvbGliL25nLWxldC5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQWlDLE1BQU0sZUFBZSxDQUFDOztBQVdoRixNQUFNLE9BQU8sY0FBYztJQUt2QiwwQ0FBMEM7SUFDMUMsWUFBb0IsYUFBK0IsRUFBVSxXQUF5QztRQUFsRixrQkFBYSxHQUFiLGFBQWEsQ0FBa0I7UUFBVSxnQkFBVyxHQUFYLFdBQVcsQ0FBOEI7UUFKOUYsWUFBTyxHQUEyQixFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxDQUFDO1FBQ25FLFlBQU8sR0FBWSxLQUFLLENBQUM7SUFHeUUsQ0FBQztJQUUzRyxJQUNJLEtBQUssQ0FBQyxLQUFRO1FBQ2QsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1FBQ3BELElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFO1lBQ2YsSUFBSSxDQUFDLGFBQWEsQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUN0RSxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQztTQUN2QjtJQUNMLENBQUM7SUFlRDs7Ozs7T0FLRztJQUNILE1BQU0sQ0FBQyxzQkFBc0IsQ0FBSSxHQUFzQixFQUFFLEdBQVE7UUFDN0QsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQzs7MkdBdENRLGNBQWM7K0ZBQWQsY0FBYzsyRkFBZCxjQUFjO2tCQUoxQixTQUFTO21CQUFDO29CQUNQLCtDQUErQztvQkFDL0MsUUFBUSxFQUFFLFNBQVM7aUJBQ3RCO2lJQVVPLEtBQUs7c0JBRFIsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERpcmVjdGl2ZSwgSW5wdXQsIFRlbXBsYXRlUmVmLCBWaWV3Q29udGFpbmVyUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG5pbnRlcmZhY2UgTmdMZXRDb250ZXh0PFQ+IHtcclxuICAgIG5nTGV0OiBUO1xyXG4gICAgJGltcGxpY2l0OiBUO1xyXG59XHJcblxyXG5ARGlyZWN0aXZlKHtcclxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogZGlyZWN0aXZlLXNlbGVjdG9yXHJcbiAgICBzZWxlY3RvcjogJ1tuZ0xldF0nXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBOZ0xldERpcmVjdGl2ZTxUPiB7XHJcblxyXG4gICAgcHJpdmF0ZSBjb250ZXh0OiBOZ0xldENvbnRleHQ8VCB8IG51bGw+ID0geyBuZ0xldDogbnVsbCwgJGltcGxpY2l0OiBudWxsIH07XHJcbiAgICBwcml2YXRlIGhhc1ZpZXc6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgdmlld0NvbnRhaW5lcjogVmlld0NvbnRhaW5lclJlZiwgcHJpdmF0ZSB0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8TmdMZXRDb250ZXh0PFQ+PikgeyB9XHJcblxyXG4gICAgQElucHV0KClcclxuICAgIHNldCBuZ0xldCh2YWx1ZTogVCkge1xyXG4gICAgICAgIHRoaXMuY29udGV4dC4kaW1wbGljaXQgPSB0aGlzLmNvbnRleHQubmdMZXQgPSB2YWx1ZTtcclxuICAgICAgICBpZiAoIXRoaXMuaGFzVmlldykge1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdDb250YWluZXIuY3JlYXRlRW1iZWRkZWRWaWV3KHRoaXMudGVtcGxhdGVSZWYsIHRoaXMuY29udGV4dCk7XHJcbiAgICAgICAgICAgIHRoaXMuaGFzVmlldyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgbmdMZXRVc2VJZlR5cGVHdWFyZDogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFzc2VydCB0aGUgY29ycmVjdCB0eXBlIG9mIHRoZSBleHByZXNzaW9uIGJvdW5kIHRvIHRoZSBgTmdMZXRgIGlucHV0IHdpdGhpbiB0aGUgdGVtcGxhdGUuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIHByZXNlbmNlIG9mIHRoaXMgc3RhdGljIGZpZWxkIGlzIGEgc2lnbmFsIHRvIHRoZSBJdnkgdGVtcGxhdGUgdHlwZSBjaGVjayBjb21waWxlciB0aGF0XHJcbiAgICAgKiB3aGVuIHRoZSBgTmdMZXRgIHN0cnVjdHVyYWwgZGlyZWN0aXZlIHJlbmRlcnMgaXRzIHRlbXBsYXRlLCB0aGUgdHlwZSBvZiB0aGUgZXhwcmVzc2lvbiBib3VuZFxyXG4gICAgICogdG8gYE5nTGV0YCBzaG91bGQgYmUgbmFycm93ZWQgaW4gc29tZSB3YXkuIEZvciBgTmdMZXRgLCB0aGUgYmluZGluZyBleHByZXNzaW9uIGl0c2VsZiBpcyB1c2VkIHRvXHJcbiAgICAgKiBuYXJyb3cgaXRzIHR5cGUsIHdoaWNoIGFsbG93cyB0aGUgc3RyaWN0TnVsbENoZWNrcyBmZWF0dXJlIG9mIFR5cGVTY3JpcHQgdG8gd29yayB3aXRoIGBOZ0xldGAuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBuZ1RlbXBsYXRlR3VhcmRfbmdMZXQ6ICdiaW5kaW5nJztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFzc2VydHMgdGhlIGNvcnJlY3QgdHlwZSBvZiB0aGUgY29udGV4dCBmb3IgdGhlIHRlbXBsYXRlIHRoYXQgYE5nTGV0YCB3aWxsIHJlbmRlci5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgcHJlc2VuY2Ugb2YgdGhpcyBtZXRob2QgaXMgYSBzaWduYWwgdG8gdGhlIEl2eSB0ZW1wbGF0ZSB0eXBlLWNoZWNrIGNvbXBpbGVyIHRoYXQgdGhlXHJcbiAgICAgKiBgTmdMZXRgIHN0cnVjdHVyYWwgZGlyZWN0aXZlIHJlbmRlcnMgaXRzIHRlbXBsYXRlIHdpdGggYSBzcGVjaWZpYyBjb250ZXh0IHR5cGUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBuZ1RlbXBsYXRlQ29udGV4dEd1YXJkPFQ+KGRpcjogTmdMZXREaXJlY3RpdmU8VD4sIGN0eDogYW55KTogY3R4IGlzIE5nTGV0Q29udGV4dDxFeGNsdWRlPFQsIGZhbHNlIHwgMCB8ICcnIHwgbnVsbCB8IHVuZGVmaW5lZD4+IHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxufVxyXG4iXX0=